
finish exception stuff
output original (be) input file and line

  nlc and nlec local arrays (not static or whatever)
  overriden (base) object call which returns int arrays for 2 methods - genned native call to get them,
  retular (final) object method which calls that and converts
  override those methods, return the arrays
  in except, check static (exceptions?) map for them (holds two array of arrays), if no present, set them up, then
  return
  
  test native and regular excepts

get win, linux, with bootstraps going (have bootstrapgen 5 for all 3 plats, diff is the zip names, all have plat, diff scripts with parent)

library/library version (onces and such not version specific) 
library versions, part of "name", major/minor

for typed vars, if they support forward could allow for calls they don't know about (and start them out "forwardcally") (now they fail)
make js and others same behaviour
  
finally
convenience syntax for array, map construction
dump { } ( ) where unneeded

---- bugs ----
default return not picking up when wrong type
return in loop seen as last return incorrectly (what if no loop...)
last call is return not working for all cases - when the last return is inside a conditional, need to check for closing }
something is wrong with classname get (for jv at least) - visiterror had it (adding " " to it, npe)
copy needs to be return type self
castTo is wrong in at least some once cases, checkTypes must be wrong somehow
byteiterator is much much slower than just doing getInt on a string by length, something is wrong there
// Bug with initial elif
// math with parens inside a method call is broken
// this doesn't work for (Int j = 0;j < dnumargs && j < maxDynArgs;j=j++) {
// numargs - maxDynArgs + 1 !== (numargs - maxDynArgs) + 1
// if undef(self[n]) doesn't seem to work (at least in Array)
// this includes negative values for indexes
// test once assign with not combination
string hash for javascript seems to be different than for others

---- lang change req ----
vars to props
  support both
  change all 
  drop vars support
iteratorGet can't be typed, that's a problem, esp foreach
  ?type obj iterator, others will have to extend 

gratuitous returns - var for untyped, rest as now (self, typed).
   void type to allow explicit def
   return; ok (void) (same as return(void);)
 enable var return type
 find and fix all cases of return without declaration
 find and fix all cases of assign from non-declared return for typed calls
 remove autoreturn for no declared return (void)
 dynamic calls return self or null? one of them... self, consistent with now, but changes behavior... or null instead? 

get rid of implied new calls in generated code (mark as implied, skip them,   
  I think it's only for literals now anyway)

---- no lang change req / additive ----

add notEmpty to containers
decide on mutating or not len for string et all and do it (thinking do)
get rid of auto-once for literal, require manual use
   do after native add/sub/etc for literals (below) to minimise impact
   output all cases where it is being done (where not manual and not optimized away), and do them all manually
make it possible to skip calls and link up assignments betw org and final
tmp var reduction
 direct use of onces, no tmp var assign (will then have mechanism to suppress existence
 of tmp vars, unnecessary assignments/use other variables, alias)
 extend call et all to get the info through ("skip"))
 skip unneeded temp/assigns
 drop tmp vars for simple calls, chain where possible
native operations, dropping literals
 have add, subtract, multiply, divide which work on literals directly (addValue, etc) (for when a literal is just immediately used with an int, etc,
   as second arg to call)
 for all those uses, get rid of onces, constructs, tmp vars, etc
 also, for many calls can avoid the call even if not literals (int add, sub, etc)
 in some cases (no escape (local vars, not called out except to "safe" mtds))   
   could do native ints, bools, same with local/final int/bool members  
=~ for setValue, reuse operand other than participants in calculation (this is more useful than all the others... will make reuse work.)
 make it a 3 argument override (addValue(oper2, intoRes) (first is self...), or better, addValue(oper1, oper2), where self is where the result ends up (and what receives the call))
final for static members (?) - readonly for c#
     onceDeced it's ok, not for not once deced (need to distinguish)
get rid of calls to once and many
get rid of calls to new where local/final and is not overridden from obj
more efficient int
  direct no call operations (?inline) (no null checking)
    have a way to mark ok for inlining anywhere, use 
    text replacement($) to arg vars instead of literal names
  native ints where completely local, initted at declare/never null, etc
    -have specific inline for int value above, which can work with direct lits
  native ints for literal cases (typed oper on literal)
  
encode/decode base 64 to use instead of hex
http://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64

add debug to mcs throughout .bat
log - level for class, config based (optional), time stamp (optional)

direct member get/set where possible (typed, final or local w/o override), keep gen accessors
see how typescript and dart translate into js
  example programs, compile to js, look at them
  https://developers.google.com/closure/compiler/
  (or don't, js is just for the browser...)

clocker iterator, share lock with clocker

ifEmit to ifSet, ifUnset, prefix lang (?em: or em. lang, like em.jv)
(or just keep ifEmit, and support external flags - this)

for buid to be threadsafe, 
   nodes and syns needs threadsafe fixes

finish notnull cleanup (reused by default logic, but improperly named, still looked for compile, syn + class mbr, etc)

allcalls missing some, self ref node thinking

utf8 in code (vars, classes, methods), encoding for < > ascii
  http://www.cprogramming.com/tutorial/unicode.html

info for embedders - main needs to run before start, outer thread should hold lock
  on lib
  
more concurrency
  semaphore
  queue
  worker threads
  futures (promises)
  atomic int ops
 .. means to back to last target (can be explicit or return from a . call) 

I think can() could be better than iterating methods :-( (will need to gen something like invoke but with just t/f)
FASTER where there are range checks in the lang (cs, jv), skip them in the external logic (may need to change except behavior for this to work)

programattic access to compiler (incl after a base tree is loaded), mostly for
 testing invalid code cases, maybe for other things too

closure? callback? lamda?
callback/event, mtd, concurrency

EcPlat can drop c emit stuff

https://github.com/int6/uhttpsharp c# embedded ws

args to if must be boolean if they are typed

get test testMisc working for js 
-js needs to check types on assign Look for formCast/checkTypes, need to rearrange call assign stuff a bit
-check assigns
-js on typed calls check during arg build, untyped calls have a descriptor obj genned which is checked

method alias - for typed, all references replaced with the other name, for dynamic, that name also calls the alias method (just like the real one...), only one instance of method, no double calls

this /* num */ I can't use... dump them.

support no file gen for (esp for js) (all in mem string in/out), and work out how to include pregenned stuff (libs)
libs for cs and jv

unify foreach and for, behavior based on parens contents, dump foreach kw
support properties method, all vars within are properties, always called at instance creation if present (bit like default)

packaging, node.js packaging is great (npm install ...) mavenish

oc? cp (cc)? php?

lang-notes:

objc arc > cpp refcount
cpp refcount - intrusive for string, external for weak

js:
http://jsperf.com/object-create-vs-crockford-vs-jorge-vs-constructor/10
http://ejohn.org/apps/learn/#64

perf
THE NEXT LINE IS THE JS SPEEDUP ONE!!! (prototype actually looks to be fastest...)
http://coding.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/
http://stackoverflow.com/questions/3493252/javascript-prototype-operator-performance-saves-memory-but-is-it-faster

back strings with regular js Array type of js integers (unsigned 8bit) for now.
Converting from this to js string:  http://stackoverflow.com/questions/14028148/convert-integer-array-to-string-at-javascript
https://stackoverflow.com/questions/2647867/how-to-determine-if-variable-is-undefined-or-null
More complete stack traces (opera, ie): http://www.eriwen.com/javascript/js-stack-trace/

later(sooner?) support js typed arrays conditionally (should be much faster/better)

cycle detect
cycle finder - in lang, "interceptors" for calls trigger at method entry (match class/call, glob?) - compile time - for assign to member for n steps out look for self to find cycles
static variables for once assign

oc:
apportable
static lib (ios req)
dynamic calls w/out switch (use built-in)
name mangling all in names (no ns available)
objc on message calls variable names are optional, can just do positions with : 
supposedly no difference in performance between typed pointers and untyped pointers for calls
http://stackoverflow.com/questions/907843/cost-of-message-dispatch-in-objective-c
arc linux - http://lists.gnu.org/archive/html/discuss-gnustep/2014-05/msg00049.html
  http://stackoverflow.com/questions/19895777/objective-c-how-is-arc-enabled-within-gnustep
arc - http://solarianprogrammer.com/2012/03/21/clang-objective-c-windows/
http://www.dev-smart.com/archives/401
(for older ios/os vers which don't do weak)
http://stackoverflow.com/questions/6893038/how-do-i-replace-weak-references-when-using-arc-and-targeting-ios-4-0
-http://longweekendmobile.com/2011/09/07/objc-automatic-reference-counting-in-xcode-explained/
-fobjc-arc-exceptions
http://clang.llvm.org/docs/AutomaticReferenceCounting.html#exceptions
-compatible weak impl for ios4 isx 10.6
http://www.mikeash.com/pyblog/introducing-plweakcompatibility.html
https://github.com/plausiblelabs/PLWeakCompatibility
http://woboq.com/blog/objective-c-for-qt-developers.html
no varname arg syntax - http://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c

other options for dynamic calls (jv, cs):
-inner class which just invokes (interface)
-dexmaker android
-cgilib reflectasm java invokedynamic
-reflection - setaccessable true, http://inferretuation.blogspot.com/2008/11/in-jit-we-trust.html reflect inflation speedup properties

end lang-notes:

int 32bit (c int, int32_t), float 32bit (c float), add long 64 (c long long) and double 64 (c double) (after conversion?)

allow signatures to mark arguments as safe - as not incorporated into members, not mutated, not passed along

only do the omission of checks for initial where there is no initialize call for closelibs
if can is fast enough enforce not setting the initial value in initialSet
FASTER make it possible to pre-set initials then skip the check for them during construct (always just use them, no null check/construct
fallthrough)
FASTER if closelib and isFinal or isLocal and call is empty skip it altogether (new, create, once, many, etc)

functional:
first class functions - alwaysForward for all dynamic calls always forwarding (the way to use functions)
distinguish getting a function from doing a accessor (have a call, also have something other for shortcut, maybe ".."
anonymous functions? closures? (case inside (no), capture everything used and make them all args/held state (yes)) 
switch invoke over?

in practice now, int is 32, long varies long long is 64
float is 32, double is 64
unicode is max 4 bytes, fits in 32bit int
have unsigned int value, for java, postive part of 64bit (long) - better because does not depend on 
signed implementation being something in particular (2s complement) for byte manipulation
shiftLeft, shiftRight, shiftRightLogical

recursive file - dir delete

Build class needs to become Builder

need more tests for time and interval

map-like get put on obj could use accessors to get/put, index too (using prop iter)

have a convention (?based on namepath) to allow direct use of emit lang as if it was native be code
auto reference to c, cpp, objc based on package name

with mutable literals convention is for the mutator to assure safety of references by copying them, assuming that unknown code may depend on the value not changing

support stream parsing along side string parsing for xml, json

support for getting all method and/or member names
-need to have a way to get all methods (iterator?)
have a class which finds all descendents of a particular class and then runs them if they support the desired method (main args params)
-will have to have a way of getting all descendents of a class

nice ideas:
hibernate/resume for programs
upgrade without restart

utf8
link for escape/unescape source
http://www.cprogramming.com/tutorial/unicode.html
a table with lots
http://www.utf8-chartable.de/
online encoder
http://www.htmlescape.net/stringescape_tool.html

easy initialization of lists and maps
have a descendent of Assertions which has a main which runs all methods which begin with (or end with) "t(T)est"

no arg and single arg calls (at least) w/out parens (return...)
use all the way down to a call, like Class.call syntax, possibly generallized macro (maybe not use, maybe let, define?), also use...as
import to bring in methods of another class, somehow need to add self to calls (make a member?  Prefix to calls)
 would mean having an implicit member of that class, calls are created (like gets/sets)
anon methods, become instances of system-method and can only be used/referenced via assignment (when genning them,
 have a different prefix for function - and they are not in any vtables, call maps, etc (they're unnamed as such, only referencable
 via variables)

smart, oldfart, ideas http://scottlocklin.wordpress.com/2013/07/28/ruins-of-forgotten-empires-apl-languages/

use private to mean a class which is only visible in it's own library 
(none of it's interface/syn goes to deploy)

think about how to support binary serialization

add files by directory/match to build list

multi value return

arbitrary precision arithmetic
btrees, binary search trees

method invocations which are final for object should be handled in a final way for untyped vars as for typed vars

support "and" and "or" along side && and || (just like you can do "not" as .not())
? foreach handle nulls gracefully (no iter) ?

closures using instances (auto-prefix)

interpreted mode for rapid dev, arrange ways for native targets

ifEmit(c:boo), ifEmit(all:foo)

// each/multiassign/return...

generics (generic type) (functionality covers interfaces, generics, mixins)

through incorporation
calls on it like dynamic calls, goes to incorporated type
check that calls of generic satisfied by incorporated type at compile time
whether or not a type supports an generic is determined by if it is ever initialized for that generic (constructed for it...)
generic indistinguishable from regular types during calls, etc (source wise, emitted code different for calls), only at declaration and construction is it different

DoIt<T>(T held) DoIt {

   return(self);
   
   doIt() {
      held.doIt();
   }
}

DoIt d = DoIt<AType>(at); //at is of type AType

d.doIt(); //doIt called on held inst (interface case)

type inference (auto)
